# Monolithic project bundle
# Generated: 2025-12-09T21:31:40Z
# Repo root: /Users/andrewshaw/PycharmProjects/Bakckend-Casa

-----8<----- FILE: .gitignore (254 bytes) -----
```
# Python virtual environment
.venv/
venv/
ENV/

# Python compiled files and cache
__pycache__/
*.py[cod]
*$py.class

# Database
app.db
*.sqlite3

# Environment variables
.env

# IDE configuration
.idea/
.vscode/

# OS generated files
.DS_Store
Thumbs.db

```
-----8<----- END FILE: .gitignore -----

-----8<----- FILE: api.yaml (4584 bytes) -----
```yaml
openapi: 3.0.0
info:
  title: OMS Backend (MVP)
  version: 1.0.0
  description: Minimal backend API for sending trading orders to Centroid through an internal FIX engine.

servers:
  - url: http://localhost:8000

paths:

  /health:
    get:
      summary: Health check
      responses:
        '200':
          description: OK

  /orders:
    post:
      summary: Create a new trading order
      description: >
        Creates an order in the local OMS. The order is persisted and then
        routed to the FIX engine which will forward it to Centroid.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OrderCreateRequest'
      responses:
        '201':
          description: Order accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
        '400':
          description: Invalid order parameters

    get:
      summary: List orders
      parameters:
        - in: query
          name: clientId
          schema:
            type: string
        - in: query
          name: symbol
          schema:
            type: string
      responses:
        '200':
          description: List of orders
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Order'

  /orders/{orderId}:
    get:
      summary: Get a single order by ID
      parameters:
        - name: orderId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Order data
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
        '404':
          description: Not found

  /orders/{orderId}/cancel:
    post:
      summary: Cancel an order
      description: >
        Requests cancellation. The FIX engine will send FIX Cancel (35=F)
        to Centroid and update status when the ExecutionReport arrives.
      parameters:
        - in: path
          name: orderId
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Cancel request accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
        '404':
          description: Order not found

  /positions:
    get:
      summary: Get current positions for a client
      parameters:
        - in: query
          name: clientId
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Positions list
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Position'

components:

  schemas:

    OrderCreateRequest:
      type: object
      required:
        - clientId
        - symbol
        - side
        - type
        - qty
      properties:
        clientId:
          type: string
        symbol:
          type: string
          example: XAUUSD
        side:
          type: string
          enum: [BUY, SELL]
        type:
          type: string
          enum: [MARKET, LIMIT]
        qty:
          type: number
        price:
          type: number
          nullable: true
        timeInForce:
          type: string
          enum: [GTC, DAY, IOC, FOK]
          default: GTC

    Order:
      type: object
      properties:
        id:
          type: string
        clientId:
          type: string
        symbol:
          type: string
        side:
          type: string
        type:
          type: string
        qty:
          type: number
        price:
          type: number
          nullable: true
        status:
          type: string
          enum:
            - NEW
            - PENDING_SEND
            - SENT
            - PARTIALLY_FILLED
            - FILLED
            - REJECTED
            - CANCELED
        cumQty:
          type: number
        avgPx:
          type: number
          nullable: true
        createdAt:
          type: string
        updatedAt:
          type: string

    Position:
      type: object
      properties:
        clientId:
          type: string
        symbol:
          type: string
        netQty:
          type: number
        avgPx:
          type: number
        unrealizedPnl:
          type: number

```
-----8<----- END FILE: api.yaml -----

-----8<----- FILE: app/__init__.py (26 bytes) -----
```python
# OMS Backend app package

```
-----8<----- END FILE: app/__init__.py -----

-----8<----- FILE: app/api.py (5037 bytes) -----
```python

from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from types import SimpleNamespace
from .db import session_scope, Base, engine
from .models import Order as OrderModel
from .schemas import OrderCreateRequest, Order as OrderSchema, Position as PositionSchema
from .repositories.orders import OrderRepository
from .repositories.positions import PositionsRepository
# Fase 2 imports
from .repositories.risk_limits import RiskLimitsRepository
from .services.risk_service import validate_order
from .services.metrics import record, snapshot
from .services.reconciliation_service import reconcile_internal
from .utils.enums import OrderStatus
from .services.fix_gateway import fix_gateway

router = APIRouter()

# Ensure tables exist (MVP)
Base.metadata.create_all(bind=engine)


def get_db():
    with session_scope() as s:
        yield s


@router.get("/health")
def health():
    return {"status": "OK"}


@router.post("/orders", response_model=OrderSchema, status_code=201)
def create_order(payload: OrderCreateRequest, db: Session = Depends(get_db)):
    """Create an order after pre-trade risk validation, persist it, commit so FIX worker can see it,
    then enqueue FIX SEND event.
    """
    # Fase 2.1 — Validación de riesgo
    risk_repo = RiskLimitsRepository(db)
    client_limit = risk_repo.by_client_symbol(payload.clientId, payload.symbol)
    # Si no hay límites definidos para el cliente, definir unos permisivos por defecto para no bloquear MVP
    if client_limit is None:
        # 24x7, sin bloqueo ni límites muy restrictivos
        client_limit = SimpleNamespace(
            client_id=payload.clientId,
            symbol=None,
            max_notional=1e12,
            max_order_size=1e9,
            trading_hours="00:00-23:59",
            blocked=False,
        )
    # Especificación del símbolo (estático)
    symbol_spec = {
        "ref_price": 2000.0 if payload.symbol.upper().startswith("XAU") else 1.10
    }

    ok, reason = validate_order(payload, client_limit, symbol_spec)
    if not ok:
        # Métricas
        record("orders_rejected", 1)
        record(f"risk_rejects:{reason}", 1)
        return JSONResponse(status_code=400, content={
            "error": "RISK_REJECT",
            "reason": reason,
        })

    # Fase 2.3 — métrica de orden aceptada
    record("orders_total", 1)

    repo = OrderRepository(db)

    order = repo.create({
        "client_id": payload.clientId,
        "symbol": payload.symbol,
        "side": payload.side.value,
        "type": payload.type.value,
        "qty": payload.qty,
        "price": payload.price,
        "time_in_force": payload.timeInForce.value,
        "status": OrderStatus.NEW.value,
    })

    db.flush()
    db.commit()     # <<< CRITICAL FIX: allow worker thread to see the order

    fix_gateway.enqueue_send(order.id)

    return to_schema(order)


@router.get("/orders", response_model=list[OrderSchema])
def list_orders(
    clientId: str | None = Query(default=None),
    symbol: str | None = Query(default=None),
    db: Session = Depends(get_db),
):
    repo = OrderRepository(db)
    items = repo.list(clientId, symbol)
    return [to_schema(o) for o in items]


@router.get("/orders/{orderId}", response_model=OrderSchema)
def get_order(orderId: str, db: Session = Depends(get_db)):
    repo = OrderRepository(db)
    order = repo.get(orderId)
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    return to_schema(order)


@router.post("/orders/{orderId}/cancel", response_model=OrderSchema)
def cancel_order(orderId: str, db: Session = Depends(get_db)):
    """Commit DB before enqueueing FIX cancel event."""
    repo = OrderRepository(db)

    order = repo.get(orderId)
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")

    db.commit()     # <<< CRITICAL FIX: persist order state before FIX cancel

    fix_gateway.enqueue_cancel(order.id)

    return to_schema(order)


@router.get("/positions", response_model=list[PositionSchema])
def positions(clientId: str = Query(...), db: Session = Depends(get_db)):
    repo = PositionsRepository(db)
    items = repo.by_client(clientId)
    return [PositionSchema(**i) for i in items]


# Fase 2.3 — Métricas
@router.get("/metrics")
def metrics():
    return snapshot()

# Fase 2.4 — Admin reconcile
@router.get("/admin/reconcile/internal")
def admin_reconcile(db: Session = Depends(get_db)):
    return reconcile_internal(db)


# --------------------------
# Mapper DB → API Schema
# --------------------------

def to_schema(o: OrderModel) -> OrderSchema:
    return OrderSchema(
        id=o.id,
        clientId=o.client_id,
        symbol=o.symbol,
        side=o.side,
        type=o.type,
        qty=o.qty,
        price=o.price,
        status=o.status,
        cumQty=o.cum_qty,
        avgPx=o.avg_px,
        createdAt=o.created_at,
        updatedAt=o.updated_at,
    )

```
-----8<----- END FILE: app/api.py -----

-----8<----- FILE: app/db.py (594 bytes) -----
```python
from contextlib import contextmanager
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, DeclarativeBase

DATABASE_URL = "sqlite:///./app.db"

engine = create_engine(
    DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

class Base(DeclarativeBase):
    pass

@contextmanager
def session_scope():
    session = SessionLocal()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()

```
-----8<----- END FILE: app/db.py -----

-----8<----- FILE: app/main.py (527 bytes) -----
```python
import uvicorn
from fastapi import FastAPI
from .api import router
from .services.fix_gateway import fix_gateway
# Fase 2.2 — WS router
from .ws import ws_router

app = FastAPI(title="OMS Backend (MVP)")

# Start FIX worker properly when FastAPI starts — THIS IS CRITICAL
@app.on_event("startup")
async def startup_event():
    fix_gateway.start()

# Add API routes
app.include_router(router)
app.include_router(ws_router)

if __name__ == "__main__":
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)

```
-----8<----- END FILE: app/main.py -----

-----8<----- FILE: app/models.py (2494 bytes) -----
```python
import uuid
from datetime import datetime
from sqlalchemy import String, Float, DateTime, ForeignKey, Boolean
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .db import Base

# ------------------------------
# Fase 2 — Nuevos modelos
# ------------------------------

class Order(Base):
    __tablename__ = "orders"

    id: Mapped[str] = mapped_column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    client_id: Mapped[str] = mapped_column(String, index=True)
    symbol: Mapped[str] = mapped_column(String, index=True)
    side: Mapped[str] = mapped_column(String)
    type: Mapped[str] = mapped_column(String)
    qty: Mapped[float] = mapped_column(Float)
    price: Mapped[float | None] = mapped_column(Float, nullable=True)
    time_in_force: Mapped[str] = mapped_column(String, default="GTC")

    status: Mapped[str] = mapped_column(String, default="NEW", index=True)
    cum_qty: Mapped[float] = mapped_column(Float, default=0.0)
    avg_px: Mapped[float | None] = mapped_column(Float, nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    executions: Mapped[list["Execution"]] = relationship("Execution", back_populates="order", cascade="all, delete-orphan")

class Execution(Base):
    __tablename__ = "executions"

    id: Mapped[str] = mapped_column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    order_id: Mapped[str] = mapped_column(String, ForeignKey("orders.id", ondelete="CASCADE"), index=True)
    exec_qty: Mapped[float] = mapped_column(Float)
    exec_px: Mapped[float] = mapped_column(Float)
    exec_time: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    order: Mapped[Order] = relationship("Order", back_populates="executions")

# Fase 2.1 — Tabla de límites de riesgo
class RiskLimit(Base):
    __tablename__ = "risk_limits"

    id: Mapped[str] = mapped_column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    client_id: Mapped[str] = mapped_column(String, index=True)
    symbol: Mapped[str | None] = mapped_column(String, nullable=True, index=True)
    max_notional: Mapped[float] = mapped_column(Float)
    max_order_size: Mapped[float] = mapped_column(Float)
    trading_hours: Mapped[str] = mapped_column(String)  # formato "HH:MM-HH:MM"
    blocked: Mapped[bool] = mapped_column(Boolean, default=False)

```
-----8<----- END FILE: app/models.py -----

-----8<----- FILE: app/repositories/orders.py (1033 bytes) -----
```python
from sqlalchemy import select
from sqlalchemy.orm import Session
from ..models import Order as OrderModel
from ..utils.enums import OrderStatus

class OrderRepository:
    def __init__(self, db: Session):
        self.db = db

    def create(self, data: dict) -> OrderModel:
        order = OrderModel(**data)
        self.db.add(order)
        self.db.flush()  # assign id
        return order

    def get(self, order_id: str) -> OrderModel | None:
        return self.db.get(OrderModel, order_id)

    def list(self, client_id: str | None, symbol: str | None) -> list[OrderModel]:
        stmt = select(OrderModel)
        if client_id:
            stmt = stmt.where(OrderModel.client_id == client_id)
        if symbol:
            stmt = stmt.where(OrderModel.symbol == symbol)
        return list(self.db.execute(stmt).scalars().all())

    def save(self, order: OrderModel):
        self.db.add(order)

    def set_status(self, order: OrderModel, status: OrderStatus):
        order.status = status
        self.db.add(order)

```
-----8<----- END FILE: app/repositories/orders.py -----

-----8<----- FILE: app/repositories/positions.py (1375 bytes) -----
```python
from sqlalchemy import select, func, case
from sqlalchemy.orm import Session
from ..models import Order, Execution

class PositionsRepository:
    def __init__(self, db: Session):
        self.db = db

    def by_client(self, client_id: str) -> list[dict]:
        signed_qty = case(
            (Order.side == "BUY", Execution.exec_qty),
            else_=-Execution.exec_qty,
        )
        sub = (
            select(
                Order.client_id.label("clientId"),
                Order.symbol.label("symbol"),
                func.sum(signed_qty).label("netQty"),
                (
                    func.sum(Execution.exec_qty * Execution.exec_px)
                    / func.nullif(func.sum(Execution.exec_qty), 0)
                ).label("avgPx"),
            )
            .join(Execution, Execution.order_id == Order.id)
            .where(Order.client_id == client_id)
            .group_by(Order.client_id, Order.symbol)
        )
        rows = self.db.execute(sub).all()
        positions = []
        for r in rows:
            net_qty = float(r.netQty or 0)
            avg_px = float(r.avgPx or 0)
            positions.append({
                "clientId": r.clientId,
                "symbol": r.symbol,
                "netQty": net_qty,
                "avgPx": avg_px,
                "unrealizedPnl": 0.0,
            })
        return positions

```
-----8<----- END FILE: app/repositories/positions.py -----

-----8<----- FILE: app/repositories/risk_limits.py (1628 bytes) -----
```python
from typing import Optional, Iterable
from sqlalchemy import select
from sqlalchemy.orm import Session
from ..models import RiskLimit

# Fase 2.1 — Repositorio CRUD para risk_limits
class RiskLimitsRepository:
    def __init__(self, db: Session):
        self.db = db

    def create(self, data: dict) -> RiskLimit:
        item = RiskLimit(**data)
        self.db.add(item)
        self.db.flush()
        return item

    def get(self, id_: str) -> Optional[RiskLimit]:
        return self.db.get(RiskLimit, id_)

    def list(self, client_id: Optional[str] = None, symbol: Optional[str] = None) -> list[RiskLimit]:
        stmt = select(RiskLimit)
        if client_id is not None:
            stmt = stmt.where(RiskLimit.client_id == client_id)
        if symbol is not None:
            stmt = stmt.where(RiskLimit.symbol == symbol)
        return list(self.db.execute(stmt).scalars().all())

    def by_client_symbol(self, client_id: str, symbol: str) -> Optional[RiskLimit]:
        """Preferir un límite específico por símbolo; si no hay, usar el general (symbol IS NULL)."""
        # Buscar límite específico
        stmt_specific = select(RiskLimit).where(
            RiskLimit.client_id == client_id,
            RiskLimit.symbol == symbol,
        )
        specific = self.db.execute(stmt_specific).scalars().first()
        if specific:
            return specific
        # Buscar límite general
        stmt_general = select(RiskLimit).where(
            RiskLimit.client_id == client_id,
            RiskLimit.symbol.is_(None),
        )
        return self.db.execute(stmt_general).scalars().first()

```
-----8<----- END FILE: app/repositories/risk_limits.py -----

-----8<----- FILE: app/schemas.py (1256 bytes) -----
```python
from datetime import datetime
from pydantic import BaseModel, Field, field_validator
from typing import Optional
from .utils.enums import Side, OrderType, TimeInForce, OrderStatus

class OrderCreateRequest(BaseModel):
    clientId: str
    symbol: str
    side: Side
    type: OrderType
    qty: float = Field(gt=0)
    price: Optional[float] = None
    timeInForce: TimeInForce = TimeInForce.GTC

    @field_validator("price")
    @classmethod
    def validate_price(cls, v, info):
        values = info.data
        otype = values.get("type")
        if otype == OrderType.LIMIT and v is None:
            raise ValueError("price is required for LIMIT orders")
        if otype == OrderType.MARKET and v is not None:
            raise ValueError("price must be null for MARKET orders")
        return v

class Order(BaseModel):
    id: str
    clientId: str
    symbol: str
    side: Side
    type: OrderType
    qty: float
    price: Optional[float] = None
    status: OrderStatus
    cumQty: float
    avgPx: Optional[float] = None
    createdAt: datetime
    updatedAt: datetime

    class Config:
        from_attributes = True

class Position(BaseModel):
    clientId: str
    symbol: str
    netQty: float
    avgPx: float
    unrealizedPnl: float

```
-----8<----- END FILE: app/schemas.py -----

-----8<----- FILE: app/services/event_bus.py (1128 bytes) -----
```python
from collections import defaultdict
from threading import Lock
from typing import Callable, Any, Dict, List

# Fase 2.2 — Event Bus in-memory (thread-safe básico)

class EventBus:
    def __init__(self):
        self.subscribers: Dict[str, List[Callable[[Any], None]]] = defaultdict(list)
        self._lock = Lock()

    def subscribe(self, topic: str, callback: Callable[[Any], None]) -> None:
        """Suscribe un callback sincrónico que recibirá `event`.
        No devuelve unsubscribe para mantenerlo simple en MVP.
        """
        with self._lock:
            self.subscribers[topic].append(callback)

    def publish(self, topic: str, event: Any) -> None:
        # Copiar lista bajo lock para evitar problemas si cambian durante iteración
        with self._lock:
            callbacks = list(self.subscribers.get(topic, []))
        for cb in callbacks:
            try:
                cb(event)
            except Exception as ex:
                # Evitar que un callback rompa a los demás
                print(f"[EventBus] callback error on {topic}: {ex}")


# Instancia global
event_bus = EventBus()

```
-----8<----- END FILE: app/services/event_bus.py -----

-----8<----- FILE: app/services/events.py (140 bytes) -----
```python
from dataclasses import dataclass

@dataclass
class SendOrderEvent:
    order_id: str

@dataclass
class CancelOrderEvent:
    order_id: str

```
-----8<----- END FILE: app/services/events.py -----

-----8<----- FILE: app/services/fix_gateway.py (5651 bytes) -----
```python
import random
import time
import threading
from queue import Queue, Empty
from sqlalchemy.orm import Session
from ..db import SessionLocal
from ..models import Order as OrderModel, Execution
from ..utils.enums import OrderStatus
from .events import SendOrderEvent, CancelOrderEvent
# Fase 2.2 — EventBus y métricas
from .event_bus import event_bus
from .metrics import record


class FixGateway:
    def __init__(self):
        # Queue of events to process
        self.queue: Queue = Queue()

        # Thread that processes events — not started here!
        self.worker_thread = None

    def start(self):
        """Start the FIX worker thread once FastAPI starts."""
        if self.worker_thread is None:
            print("Starting FIX worker thread...")
            self.worker_thread = threading.Thread(
                target=self._worker,
                daemon=True
            )
            self.worker_thread.start()

    def enqueue_send(self, order_id: str):
        print(f"[FIX] Enqueued SEND {order_id}")
        self.queue.put(SendOrderEvent(order_id))

    def enqueue_cancel(self, order_id: str):
        print(f"[FIX] Enqueued CANCEL {order_id}")
        self.queue.put(CancelOrderEvent(order_id))

    def _worker(self):
        print("FIX worker STARTED")
        while True:
            try:
                evt = self.queue.get(timeout=1)
            except Empty:
                continue

            try:
                if isinstance(evt, SendOrderEvent):
                    self._process_send(evt.order_id)
                elif isinstance(evt, CancelOrderEvent):
                    self._process_cancel(evt.order_id)
            finally:
                self.queue.task_done()

    def _publish_update(self, order: OrderModel):
        event_bus.publish(
            f"orders.{order.client_id}",
            {
                "type": "ORDER_UPDATE",
                "orderId": order.id,
                "status": order.status,
                "cumQty": order.cum_qty,
                "avgPx": order.avg_px,
            },
        )
        record("fix_events_processed", 1)

    def _process_send(self, order_id: str):
        with SessionLocal() as db:
            order = db.get(OrderModel, order_id)
            if not order:
                print(f"[FIX] Order NOT FOUND: {order_id}")
                return

            # Move to PENDING_SEND
            order.status = OrderStatus.PENDING_SEND
            db.add(order)
            db.commit()
            print(f"[FIX] Order {order_id} → PENDING_SEND")
            self._publish_update(order)

            time.sleep(0.2)  # simulate delay
            order.status = OrderStatus.SENT
            db.add(order)
            db.commit()
            print(f"[FIX] Order {order_id} → SENT")
            self._publish_update(order)

            # Process fills
            remaining = order.qty - order.cum_qty
            if remaining <= 0:
                return

            # 10% reject chance
            if random.random() < 0.1:
                order.status = OrderStatus.REJECTED
                db.add(order)
                db.commit()
                print(f"[FIX] Order {order_id} → REJECTED")
                self._publish_update(order)
                return

            # Simulate fill or partial fill
            partial = random.random() < 0.5
            lot1 = remaining * (0.4 if partial else 1.0)
            px = order.price or self._mock_market_px(order.symbol)

            # First fill
            exec1 = Execution(order_id=order.id, exec_qty=lot1, exec_px=px)
            db.add(exec1)
            order.cum_qty += lot1
            order.avg_px = px if order.avg_px is None else (order.avg_px + px) / 2
            order.status = (
                OrderStatus.PARTIALLY_FILLED
                if order.cum_qty < order.qty
                else OrderStatus.FILLED
            )
            db.add(order)
            db.commit()
            print(f"[FIX] Order {order_id} filled {lot1} @ {px}")
            self._publish_update(order)

            # If partial, finish later
            if order.cum_qty < order.qty:
                time.sleep(0.3)
                lot2 = order.qty - order.cum_qty
                exec2 = Execution(order_id=order.id, exec_qty=lot2, exec_px=px)
                db.add(exec2)
                order.cum_qty += lot2
                order.avg_px = px if order.avg_px is None else (order.avg_px + px) / 2
                order.status = OrderStatus.FILLED
                db.add(order)
                db.commit()
                print(f"[FIX] Order {order_id} final fill {lot2} @ {px}")
                self._publish_update(order)

    def _process_cancel(self, order_id: str):
        with SessionLocal() as db:
            order = db.get(OrderModel, order_id)
            if not order:
                print(f"[FIX] Cancel ignored: Order not found {order_id}")
                return

            if order.status in (
                OrderStatus.FILLED,
                OrderStatus.CANCELED,
                OrderStatus.REJECTED,
            ):
                print(f"[FIX] Cancel ignored: Order {order_id} already terminal")
                return

            time.sleep(0.2)
            order.status = OrderStatus.CANCELED
            db.add(order)
            db.commit()
            print(f"[FIX] Order {order_id} → CANCELED")
            self._publish_update(order)

    def _mock_market_px(self, symbol: str) -> float:
        base = 2000.0 if symbol.upper().startswith("XAU") else 1.1000
        return round(base + random.uniform(-1, 1), 2)


# Global instance
fix_gateway = FixGateway()

```
-----8<----- END FILE: app/services/fix_gateway.py -----

-----8<----- FILE: app/services/metrics.py (948 bytes) -----
```python
from collections import defaultdict
from typing import Dict, Any

# Fase 2.3 — Métricas básicas (in-memory)

_orders_total = 0
_orders_rejected = 0
_risk_rejects: Dict[str, int] = defaultdict(int)
_fix_events_processed = 0


def record(metric_name: str, value: int = 1):
    global _orders_total, _orders_rejected, _fix_events_processed
    if metric_name == "orders_total":
        _orders_total += value
    elif metric_name == "orders_rejected":
        _orders_rejected += value
    elif metric_name.startswith("risk_rejects:"):
        reason = metric_name.split(":", 1)[1]
        _risk_rejects[reason] += value
    elif metric_name == "fix_events_processed":
        _fix_events_processed += value


def snapshot() -> dict[str, Any]:
    return {
        "orders_total": _orders_total,
        "orders_rejected": _orders_rejected,
        "risk_rejects": dict(_risk_rejects),
        "fix_events_processed": _fix_events_processed,
    }

```
-----8<----- END FILE: app/services/metrics.py -----

-----8<----- FILE: app/services/reconciliation_service.py (3824 bytes) -----
```python
from collections import defaultdict
from typing import Dict, List
from sqlalchemy.orm import Session
from sqlalchemy import select, func
from ..models import Order, Execution
from ..repositories.positions import PositionsRepository
from ..utils.enums import OrderStatus

# Fase 2.4 — Reconciliación interna

def reconcile_internal(db: Session) -> dict:
    """
    Verifica:
      - order.cum_qty == sum(executions)
      - status es coherente con qty y cum_qty
      - positions coinciden con executions
    Retorna dict con inconsistencias.
    """
    orders_inconsistent: List[dict] = []

    # Precompute sums of executions per order
    stmt_exec_sums = (
        select(Execution.order_id, func.sum(Execution.exec_qty).label("sum_exec"))
        .group_by(Execution.order_id)
    )
    exec_sums = {row.order_id: float(row.sum_exec or 0.0) for row in db.execute(stmt_exec_sums)}

    # Check orders
    orders = db.execute(select(Order)).scalars().all()
    for o in orders:
        s = float(exec_sums.get(o.id, 0.0))
        inco_reasons: List[str] = []
        if abs((o.cum_qty or 0.0) - s) > 1e-9:
            inco_reasons.append("CUM_QTY_MISMATCH")

        # Coherence with qty and cum_qty
        qty = float(o.qty or 0.0)
        cum = float(o.cum_qty or 0.0)
        st = OrderStatus(o.status)
        if st == OrderStatus.FILLED and abs(cum - qty) > 1e-9:
            inco_reasons.append("STATUS_FILLED_BUT_CUM_QTY_NE_QTY")
        if st == OrderStatus.PARTIALLY_FILLED and (cum <= 0 or cum >= qty):
            inco_reasons.append("STATUS_PARTIAL_INCONSISTENT")
        if st != OrderStatus.FILLED and abs(cum - qty) <= 1e-9 and qty > 0:
            inco_reasons.append("STATUS_NOT_FILLED_BUT_CUM_EQ_QTY")

        if inco_reasons:
            orders_inconsistent.append({
                "orderId": o.id,
                "status": o.status,
                "qty": qty,
                "cumQty": cum,
                "reasons": inco_reasons,
            })

    # Positions vs executions
    positions_inconsistent: List[dict] = []
    # Build positions from executions
    # For each execution, sign depends on order side
    # We need order sides for executions; join executions with orders
    stmt_exec_detail = select(
        Order.client_id, Order.symbol, Order.side, Execution.exec_qty, Execution.exec_px
    ).join(Execution, Execution.order_id == Order.id)
    rows = db.execute(stmt_exec_detail).all()

    agg = defaultdict(float)
    notional = defaultdict(float)
    for r in rows:
        sign = 1.0 if r.side == "BUY" else -1.0
        agg[(r.client_id, r.symbol)] += sign * float(r.exec_qty)
        notional[(r.client_id, r.symbol)] += float(r.exec_qty) * float(r.exec_px)

    # Repo positions
    repo = PositionsRepository(db)
    repo_pos = repo.by_client  # function

    # Compare per client found
    clients = {cid for (cid, _sym) in agg.keys()}
    for cid in clients:
        calc = {(cid, sym): qty for (cid2, sym), qty in agg.items() if cid2 == cid}
        # Convert repo list to mapping
        repolist = repo_pos(cid)
        repo_map = {(p["clientId"], p["symbol"]): float(p["netQty"]) for p in repolist}
        # Compare keys union
        keys = set(calc.keys()) | set(repo_map.keys())
        for key in keys:
            a = float(calc.get(key, 0.0))
            b = float(repo_map.get(key, 0.0))
            if abs(a - b) > 1e-9:
                positions_inconsistent.append({
                    "clientId": key[0],
                    "symbol": key[1],
                    "calcNetQty": a,
                    "repoNetQty": b,
                })

    ok = not orders_inconsistent and not positions_inconsistent
    return {
        "ok": ok,
        "orders_inconsistent": orders_inconsistent,
        "positions_inconsistent": positions_inconsistent,
    }

```
-----8<----- END FILE: app/services/reconciliation_service.py -----

-----8<----- FILE: app/services/risk_service.py (2815 bytes) -----
```python
from datetime import datetime, time as time_cls
from typing import Any, Tuple

# Fase 2.1 — Servicio de riesgo (pre-trade)


def _parse_trading_hours(th: str) -> tuple[datetime, datetime] | tuple[time_cls, time_cls]:
    """Parsea string "HH:MM-HH:MM" a tupla de times.
    No gestiona spans de día (e.g., 22:00-02:00) para mantenerlo simple MVP.
    """
    try:
        start_s, end_s = th.split("-")
        sh, sm = [int(x) for x in start_s.split(":")]
        eh, em = [int(x) for x in end_s.split(":")]
        return time_cls(sh, sm), time_cls(eh, em)
    except Exception:
        # si formato inválido, forzar rechazo por seguridad
        return time_cls(23, 59), time_cls(0, 0)


def validate_order(order_request: Any, client_risk: Any, symbol_spec: dict) -> Tuple[bool, str | None]:
    """
    Valida un request de orden contra límites de riesgo y especificación del símbolo.
    Reglas:
      - qty > 0
      - si type == LIMIT → price requerido
      - si type == MARKET → price debe ser None
      - notional = qty * price (si MARKET usar precio de referencia del symbol_spec)
      - notional <= max_notional
      - qty <= max_order_size
      - hora actual ∈ trading_hours (string tipo "09:00-16:00")
      - símbolo no bloqueado
    Retorna (ok, reason) donde reason es un string con la causa del rechazo.
    """
    # qty > 0
    qty = float(order_request.qty)
    if qty <= 0:
        return False, "INVALID_QTY"

    otype = getattr(order_request, "type")
    price = getattr(order_request, "price", None)

    # coherencia de precio según tipo
    if str(otype) in ("OrderType.LIMIT", "LIMIT"):
        if price is None:
            return False, "PRICE_REQUIRED"
    if str(otype) in ("OrderType.MARKET", "MARKET"):
        if price is not None:
            return False, "PRICE_NOT_ALLOWED"

    # símbolo bloqueado
    if getattr(client_risk, "blocked", False):
        return False, "SYMBOL_BLOCKED"

    # horario de trading
    th = getattr(client_risk, "trading_hours", "00:00-23:59")
    start_t, end_t = _parse_trading_hours(th)
    now_t = datetime.now().time()
    if not (start_t <= now_t <= end_t):
        return False, "OUTSIDE_TRADING_HOURS"

    # notional
    if price is None:
        ref_px = symbol_spec.get("ref_price")
        try:
            price = float(ref_px)
        except Exception:
            return False, "MISSING_REFERENCE_PRICE"
    notional = qty * float(price)
    max_notional = float(getattr(client_risk, "max_notional", float("inf")))
    if notional > max_notional:
        return False, "NOTIONAL_LIMIT_EXCEEDED"

    # tamaño máximo por orden
    max_order_size = float(getattr(client_risk, "max_order_size", float("inf")))
    if qty > max_order_size:
        return False, "ORDER_SIZE_LIMIT_EXCEEDED"

    return True, None

```
-----8<----- END FILE: app/services/risk_service.py -----

-----8<----- FILE: app/utils/enums.py (461 bytes) -----
```python
from enum import Enum

class Side(str, Enum):
    BUY = "BUY"
    SELL = "SELL"

class OrderType(str, Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"

class TimeInForce(str, Enum):
    GTC = "GTC"
    DAY = "DAY"
    IOC = "IOC"
    FOK = "FOK"

class OrderStatus(str, Enum):
    NEW = "NEW"
    PENDING_SEND = "PENDING_SEND"
    SENT = "SENT"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    FILLED = "FILLED"
    REJECTED = "REJECTED"
    CANCELED = "CANCELED"

```
-----8<----- END FILE: app/utils/enums.py -----

-----8<----- FILE: app/ws.py (1093 bytes) -----
```python
import asyncio
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from .services.event_bus import event_bus

# Fase 2.2 — WebSockets de órdenes por cliente

ws_router = APIRouter()


@ws_router.websocket("/ws/orders/{client_id}")
async def ws_orders(websocket: WebSocket, client_id: str):
    await websocket.accept()

    loop = asyncio.get_running_loop()
    queue: asyncio.Queue = asyncio.Queue()

    def on_event(evt):
        # Recibir desde hilos externos de FIX, pasar al loop de asyncio
        loop.call_soon_threadsafe(queue.put_nowait, evt)

    # Suscribir al tópico del cliente
    topic = f"orders.{client_id}"
    event_bus.subscribe(topic, on_event)

    try:
        while True:
            # Intentar enviar eventos pendientes
            try:
                evt = queue.get_nowait()
            except asyncio.QueueEmpty:
                evt = None
            if evt is not None:
                await websocket.send_json(evt)
            await asyncio.sleep(0.1)
    except WebSocketDisconnect:
        # Conexión terminada por el cliente
        return

```
-----8<----- END FILE: app/ws.py -----

-----8<----- FILE: flatten.sh (3251 bytes) -----
```bash
#!/usr/bin/env bash
# Flatten this repository into a single monolithic text file for LLM analysis.
# Usage:
#   ./flatten.sh [OUTPUT_FILE]
# Default OUTPUT_FILE is project_monolith.txt in repo root.
# Notes:
# - Only text files are included (based on `file --mime`), binaries are skipped.
# - Common junk/virtual/cache directories are excluded.
# - Each file is wrapped with a clear delimiter that includes its relative path.

set -euo pipefail

# Determine repo root (directory of this script)
REPO_ROOT="$(cd "$(dirname "$0")" && pwd)"
cd "$REPO_ROOT"

OUTPUT_FILE="${1:-project_monolith.txt}"

# Stat helper supporting macOS and Linux
file_size() {
  local f="$1"
  if command -v gstat >/dev/null 2>&1; then
    gstat -c %s "$f"
  elif stat -f %z "$f" >/dev/null 2>&1; then
    stat -f %z "$f"  # macOS
  else
    stat -c %s "$f"  # Linux
  fi
}

# Decide if a file is text (skip binaries)
is_text_file() {
  local f="$1"
  local mt
  mt=$(file -b --mime-type "$f" 2>/dev/null || echo "application/octet-stream")
  [[ "$mt" == text/* || "$mt" == application/json || "$mt" == application/xml || "$mt" == application/x-sh ]] \
    && return 0 || return 1
}

# Exclude patterns
should_exclude() {
  local f="$1"
  case "$f" in
    ./$(basename "$OUTPUT_FILE") ) return 0;;
    ./.git/*|.git) return 0;;
    ./.svn/*|.svn) return 0;;
    ./.hg/*|.hg) return 0;;
    ./.idea/*|.idea) return 0;;
    ./.vscode/*|.vscode) return 0;;
    ./node_modules/*|node_modules) return 0;;
    ./.venv/*|.venv) return 0;;
    ./venv/*|venv) return 0;;
    ./*__pycache__/*|*__pycache__*) return 0;;
    ./.pytest_cache/*|.pytest_cache) return 0;;
    ./.mypy_cache/*|.mypy_cache) return 0;;
    ./.coverage|.coverage) return 0;;
    ./*.pyc|*.pyc) return 0;;
    ./dist/*|dist) return 0;;
    ./build/*|build) return 0;;
    ./*.db|*.db) return 0;;
    ./*.sqlite|*.sqlite) return 0;;
    ./*.sqlite3|*.sqlite3) return 0;;
    ./.DS_Store|.DS_Store) return 0;;
    *) return 1;;
  esac
}

# Initialize output
: > "$OUTPUT_FILE"

# Header
{
  echo "# Monolithic project bundle"
  echo "# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  echo "# Repo root: $REPO_ROOT"
  echo
} >> "$OUTPUT_FILE"

# Collect and sort files

append_file() {
  local f="$1"
  local rel="${f#./}"
  local size
  size=$(file_size "$f" 2>/dev/null || echo 0)

  # Delimiter header
  {
    echo "-----8<----- FILE: $rel ($size bytes) -----"
    # Provide an indicative code fence for some common types
    case "$rel" in
      *.py) echo '```python';;
      *.yaml|*.yml) echo '```yaml';;
      *.json) echo '```json';;
      *.sh) echo '```bash';;
      *.md) echo '```markdown';;
      *) echo '```';;
    esac
    cat "$f"
    echo
    echo '```'
    echo "-----8<----- END FILE: $rel -----"
    echo
  } >> "$OUTPUT_FILE"
}

# Iterate sorted file list in a portable way (no mapfile)
find . -type f \
  ! -name ".git" -a ! -path "*/.git/*" \
  -print | LC_ALL=C sort | while IFS= read -r f; do
  # Skip the output file itself and excluded paths
  if should_exclude "$f"; then
    continue
  fi
  # Include only text-like files
  if is_text_file "$f"; then
    append_file "$f"
  fi
done

# Summary footer
{
  echo "# End of bundle"
} >> "$OUTPUT_FILE"

echo "Created monolith: $OUTPUT_FILE"

```
-----8<----- END FILE: flatten.sh -----

-----8<----- FILE: requirements.txt (114 bytes) -----
```
fastapi==0.115.2
uvicorn==0.30.6
SQLAlchemy==2.0.36
pydantic==2.9.2
pydantic-settings==2.6.1
python-dotenv==1.0.1

```
-----8<----- END FILE: requirements.txt -----

-----8<----- FILE: smoke_tests.py (2963 bytes) -----
```python
#!/usr/bin/env python3
import time
import uuid
import requests

BASE = "http://localhost:8000"

# ----------------------
# Helper functions
# ----------------------

def check_health():
    print(">> Checking /health ...")
    r = requests.get(f"{BASE}/health")
    assert r.status_code == 200
    assert r.json().get("status") == "OK"
    print("   PASSED")


def create_order():
    print(">> Creating order /orders ...")
    payload = {
        "clientId": "SMOKE",
        "symbol": "XAUUSD",
        "side": "BUY",
        "type": "LIMIT",
        "qty": 1,
        "price": 2000.0,
        "timeInForce": "GTC",
    }
    r = requests.post(f"{BASE}/orders", json=payload)
    assert r.status_code == 201, f"Expected 201, got {r.status_code}"
    order = r.json()
    print("   Order created:", order["id"])
    return order["id"]


def get_order(order_id):
    r = requests.get(f"{BASE}/orders/{order_id}")
    assert r.status_code == 200, "Expected 200 for GET order"
    return r.json()


def wait_for_order_state_change(order_id, max_wait=3.0, interval=0.2):
    print(">> Waiting for order state to change from NEW ...")

    elapsed = 0
    while elapsed < max_wait:
        order = get_order(order_id)
        if order["status"] != "NEW":
            print(f"   Status changed to: {order['status']}")
            return order
        time.sleep(interval)
        elapsed += interval

    raise AssertionError("Order stayed in NEW state too long — FIX mock may not be running")


def list_orders():
    print(">> Listing /orders?clientId=SMOKE ...")
    r = requests.get(f"{BASE}/orders", params={"clientId": "SMOKE"})
    assert r.status_code == 200
    data = r.json()
    print(f"   Found {len(data)} orders")
    return data


def cancel_fake_order():
    print(">> Cancelling non-existing order (expect 404) ...")
    fake_id = str(uuid.uuid4())
    r = requests.post(f"{BASE}/orders/{fake_id}/cancel")
    assert r.status_code == 404, f"Expected 404, got {r.status_code}"
    print("   PASSED (404 received)")


def get_positions():
    print(">> GET /positions?clientId=SMOKE ...")
    r = requests.get(f"{BASE}/positions", params={"clientId": "SMOKE"})
    assert r.status_code == 200
    positions = r.json()
    print("   Positions:", positions)
    return positions


# ----------------------
# Smoke Test Runner
# ----------------------

def run():
    print("\n=== SMOKE TESTS START ===\n")

    check_health()

    order_id = create_order()

    # Wait for FIX mock to process fills
    order = wait_for_order_state_change(order_id)

    # Final state must be one of:
    valid_states = (
        "PENDING_SEND",
        "SENT",
        "PARTIALLY_FILLED",
        "FILLED",
        "REJECTED",
    )
    assert order["status"] in valid_states, f"Unexpected status: {order['status']}"

    list_orders()
    cancel_fake_order()
    get_positions()

    print("\n=== ALL SMOKE TESTS PASSED ===\n")


if __name__ == "__main__":
    run()

```
-----8<----- END FILE: smoke_tests.py -----

# End of bundle
